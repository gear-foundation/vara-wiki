---
title: Ethereum ↔ Vara App guilde
sidebar_position: 6
sidebar_label: Ethereum ↔ Vara App guilde
---

# Ethereum → Vara App Guide

## Introduction

This article covers the flow for building a cross-chain application from **Ethereum to Vara**. We will show how to design an event-based “ping-pong” app, where the message originates on Ethereum and is securely delivered and processed on Vara.

Unlike the reverse direction (Vara → Ethereum), where ZK-proofs are used to guarantee trustless delivery, the **Ethereum → Vara** route is based on a **Light Client** mechanism. Here, there are no ZK-proofs on the Ethereum side. Instead, trust is achieved through on-chain light client validation of Ethereum’s consensus — specifically, through the **beacon chain** and its finalized checkpoints.

In this design, **event logs** on Ethereum become the source of truth. Applications emit events as part of contract execution. These events are included in Ethereum's canonical chain history (the beacon chain), and can be cryptographically proven by anyone — but only after finality is reached on Ethereum.

A permissionless relayer observes the beacon chain, builds receipt proofs for the relevant events, and submits them to Vara. On Vara, a light client validates that the proof corresponds to an actually finalized event on Ethereum, and only then is your custom Vara program triggered.

This mechanism is fundamentally **event-based** and asynchronous. Application developers do not build the bridge or proof logic themselves — they simply emit and handle events, while the trustless bridge and relayers handle the heavy lifting.


### Flow Overview

At a high level, the cross-chain message flow from **Ethereum → Vara** is:

1. **A user calls `ping()` on the Ethereum contract.**  
   The contract emits a `PingFromEthereum(address)` event.
2. **A relayer (off-chain) observes the event.**  
   The relayer generates a receipt proof and associates it with a chain slot (using beacon chain timestamp).
3. **The relayer waits for a corresponding checkpoint on Vara.**  
   Once the relevant checkpoint is available, it submits the proof to a bridge proxy program on Vara.
4. **The bridge program on Vara verifies the proof.**  
   If the proof is valid, it calls your custom program/contract on Vara, which can process the “ping” (emit a “pong”, trigger logic, etc.).
5. **Your Vara program receives the cross-chain message and acts.**  
   The cycle is complete, with cryptographic auditability on both chains.

## What You Don’t Implement

You do **not** need to implement any transport or synchronization logic between Ethereum and Vara.  
All low-level mechanics — including slot synchronization, beacon chain tracking, and finality validation — are already handled by the protocol.

- **Slot synchronization** is fully managed by the Checkpoint Light Client contract on Vara.  
  This smart contract keeps Vara up to date with finalized slots and checkpoints from Ethereum.

**In summary:**  
You only focus on emitting and listening for relevant events, and on writing your application logic.  
All cross-chain transport and slot-level synchronization are already built into the bridge infrastructure.

---

## High-Level Architecture

[Complete the source code on GitHub](https://github.com/gear-foundation/eth-vara-cross-ping)

At a high level, the Ethereum → Vara cross-chain application consists of three core components:

1. **Ethereum Smart Contract (Ping Emitter)**
    - A simple contract (e.g., `EthPinger`) with a `ping()` method that emits a `PingFromEthereum` event.

2. **Relayer Service (Off-chain)**
    - Watches for specific events on Ethereum (such as `PingFromEthereum`).
    - For each detected event:
        - **Determines the corresponding Ethereum slot** using the beacon chain (calculating the slot number from the block timestamp).
        - **Builds a cryptographic proof** (receipt inclusion proof) for the event, using libraries like `eth-proof`.
        - **Prepares a message package** containing:
            - The inclusion proof,
            - The destination program address/route on Vara,
            - The destination program API details and payload (i.e., the method/route to call, plus relevant data).
        - **Waits for the slot to be finalized** on Vara, tracked by the Checkpoint Light Client contract.
        - **Submits the package to the Historical Proxy** on Vara only when the slot has been finalized.

3. **Vara Programs (Receiver & Bridge)**
    - **Checkpoint Light Client**  
      Tracks finalized Ethereum slots and is the root of trust for incoming proofs.
    - **Historical Proxy**  
      Receives the package from the relayer, validates the proof and slot against the Checkpoint Light Client, and if valid, forwards the payload to the specified application program.
    - **Application Program (Ping Receiver)**  
      Implements a required interface, receives the proof, slot, and payload, and processes them (for example, by emitting an event or updating state).

## Implementation details

### Ethereum Side

On Ethereum, you deploy a simple contract that exposes a `ping()` function and emits a `PingFromEthereum` event:

[Source code on GitHub](https://github.com/gear-foundation/eth-vara-cross-ping/tree/master/eth-pinger)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract EthPinger {
    event PingFromEthereum(address indexed from);

    function ping() external {
        emit PingFromEthereum(msg.sender);
    }
}
```

#### Implementation Details: Relayer Side

The relayer is a permissionless off-chain service that delivers events and proofs from Ethereum to Vara.

[Source code on GitHub](https://github.com/gear-foundation/eth-vara-cross-ping/tree/master/relayer)

**Step-by-step breakdown:**

1. **Connect to both Ethereum and Vara, create a keyring for Vara:**

    ```js
    await connectVara();
    const ethApi = await connectEthereum();
    const wallet = connectWallet(); // uses VARA_MNEMONIC_KEY
    ```

2. **Listen for `PingFromEthereum` events on Ethereum:**  
   The relayer subscribes to events from the `EthPinger` contract using ethers.js:

    ```js
    function listenPingFromEthereum(provider, onPing) {
        const contract = new ethers.Contract(ETH_CONTRACT_ADDRESS, ETH_PINGER_ABI, provider);
        contract.on('PingFromEthereum', (from, payload) => {
            onPing(from, payload.log);
        });
        console.log('Listening for PingFromEthereum events at:', ETH_CONTRACT_ADDRESS);
    }

    // Usage:
    listenPingFromEthereum(ethApi, async (from, event) => {
        // see next steps
    });
    ```

3. **Calculate the slot for the event:**  
   Slot is calculated based on the **block timestamp** and Holesky genesis.

    ```js
    // Calculate slot number for an Ethereum event
    async function getSlotForEvent(event, provider) {
        const block = await provider.getBlock(event.blockNumber);
        if (!block) throw new Error(`Block not found for number: ${event.blockNumber}`);
        const timestamp = block.timestamp;
        const GENESIS = 1695902400; // Holesky genesis timestamp
        const slot = Math.floor((timestamp - GENESIS) / 12);
        return slot;
    }
    ```

4. **Build the proof for the event:**  
   The relayer constructs a proof of event inclusion using `eth-proof and RLP`.

    ```js
    // Generate receipt inclusion proof for the txHash
    async function generateProof(txHash) {
        const proof = new GetProof(ETHEREUM_HTTPS_RPC_URL);
        const result = await proof.receiptProof(txHash);

        // Flatten and encode to hex using RLP
        const headerArr = Array.from(result.header, h => Buffer.from(h));
        const proofArr = Array.from(result.receiptProof, branch => Array.from(branch, b => Buffer.from(b)));
        const txIndexBuf = Buffer.from(
            typeof result.txIndex === "string" ? result.txIndex.replace(/^0x/, "") : [result.txIndex],
            "hex"
        );
        const proofTuple = [headerArr, proofArr, txIndexBuf];
        const serializedProof = '0x' + Buffer.from(rlp.encode(proofTuple)).toString('hex');
        return serializedProof;
    }
    ```

5. **Prepare and queue the message for relay:**

    ```js
    // Inside event handler
    const slot = await getSlotForEvent(event, ethApi);
    const proof = await generateProof(event.transactionHash);
    const msg = {
        from,
        blockNumber: event.blockNumber,
        txHash: event.transactionHash,
        slot,
        proof,
    };
    pingMessages.push(msg);
    ```

6. **Listen for new checkpoints on Vara (Checkpoint Light Client):**  
   As soon as the required slot is finalized on Vara, relay the message:

    ```js
    function listenForNewCheckpoint(sailsCheckpoint, onNewCheckpoint) {
        sailsCheckpoint.services.ServiceSyncUpdate.events.NewCheckpoint.subscribe((data) => {
            onNewCheckpoint({
                slot: data.slot,
                tree_hash_root: data.tree_hash_root,
            });
        });
    }

    listenForNewCheckpoint(sailsCheckpoint, (event) => {
        lastVaraSlot = Number(event.slot);
        const ready = pingMessages.filter(msg => lastVaraSlot !== null && msg.slot <= lastVaraSlot);
        if (ready.length) {
            sendToHistoricalProxy(sailsHistorical, wallet, ready[0]);
        }
        // Clean up sent messages
        pingMessages = pingMessages.filter(msg => lastVaraSlot === null || msg.slot > lastVaraSlot);
    });
    ```

7. **Send the message to the `HistoricalProxy` on Vara:**  
   Data sent includes slot, proof, destination program ID, route

    ```js
    async function sendToHistoricalProxy(sailsHistorical, wallet, msg) {
        const slot = msg.slot;
        const proof = msg.proof;
        const clientRoute = routeToHex(PING_RECEIVER_ROUTE);

        const trx = await sailsHistorical.services.HistoricalProxy.functions.Redirect(
            slot,
            proof,
            PING_RECEIVER_PROGRAM_ID,
            clientRoute
        );
        trx.withAccount(wallet);
        await trx.calculateGas();
        const result = await trx.signAndSend();

        console.log("Message sent to HistoricalProxy, result:", result);
    }
    ```

**Summary:**
- The relayer connects to both chains, listens for events, computes slot and proof, waits for checkpoint, and relays to Vara only when the event is finalized and provable.
- All heavy lifting (proof construction, slot calculation, checkpoint monitoring) is automated via open-source libraries and scripts.


### Vara Side

On the Vara side, your application is a Rust smart contract (Gear program) that implements a service interface to receive cross-chain messages from Ethereum.

[Source code on GitHub](https://github.com/gear-foundation/eth-vara-cross-ping/tree/master/ping-receiver)

**How it works:**
- The relayer, via HistoricalProxy, delivers messages by calling the `send_message` function (or route) on your program.
- This entrypoint receives three arguments: `slot`, `transaction_index`, and `receipt_rlp`. [See the source code in HistoricalProxy](https://github.com/gear-tech/gear-bridges/blob/main/gear-programs/historical-proxy/app/src/service.rs)
- Your service interface (route) must accept these parameters.

**Example implementation:**

```rust
#![no_std]
use sails_rs::prelude::*;

#[derive(Debug, Encode, Decode, TypeInfo)]
pub struct PingFromEthereum {
    pub slot: u64,
    pub transaction_index: u32,
    pub receipt_rlp: Vec<u8>,
}

#[derive(Debug, Encode, Decode, TypeInfo)]
pub enum Event {
    PingFromEthereum(PingFromEthereum),
}

pub struct PingReceiverService;

#[service(events = Event)]
impl PingReceiverService {
    // Entry point called by HistoricalProxy via send_message
    pub fn submit_receipt(
        &mut self,
        slot: u64,
        transaction_index: u32,
        receipt_rlp: Vec<u8>,
    ) {
        self.emit_event(Event::PingFromEthereum(PingFromEthereum {
            slot,
            transaction_index,
            receipt_rlp,
        }))
        .expect("Failed to emit event");
    }
}

pub struct PingReceiverProgram;

#[sails_rs::program]
impl PingReceiverProgram {
    pub fn new() -> Self {
        Self
    }
    pub fn ping_receiver(&self) -> PingReceiverService {
        PingReceiverService
    }
}
```

### How Do I Know It Works?

- **Slot synchronization** with the Light Client takes around **15–20 minutes** (after the Ethereum event is finalized).
- Once the slot is finalized, you will see a message from HistoricalProxy delivered to your application program on Vara.
- You can verify this using [Gear Idea](https://idea.gear-tech.io/) or any Vara explorer by checking your program’s messages and emitted events.

