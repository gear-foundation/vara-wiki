---
title: Vara ↔ Ethereum App guilde
sidebar_position: 5
sidebar_label: Vara ↔ Eth App guide
---

# Introduction

Cross-chain communication can seem complex, but at its core, it’s about securely moving messages and value between independent blockchains. To make this process clear and approachable, we’ll build a minimal “ping-pong” application on top of the **Vara ↔ Ethereum Bridge**.

:::note
The ping-pong pattern is a classic example used in distributed systems to demonstrate reliable message delivery: a simple “ping” sent from one chain and a “pong” received in response from the other.
:::

In this first part, we focus on the flow from Vara to Ethereum using the bridge’s built-in ZK-based mechanism. We’ll walk through how the protocol handles the heavy lifting—cryptographic proofs, relaying, and validation—while letting developers concentrate on the application logic. In future articles, we’ll explore the reverse direction (Ethereum to Vara) and additional cross-chain patterns.

## High-Level Architecture

At a high level, the cross-chain ping-pong app consists of three main parts, each focused on its own responsibility while relying on the bridge’s secure protocol layer:

1. **On Vara:** a Gear Program on Rust acts as the Ping sender. It packages a simple payload and sends it using the built-in bridge API, specifying the destination contract on Ethereum.  
   [See Vara Program Code](https://github.com/gear-foundation/vara-eth-cross-ping/tree/main/cross-ping)
2. **In the middle:** a permissionless relayer listens for events, retrieves the required Merkle root (which guarantees the message’s existence in the queue), obtains the necessary 'Merkle proof', and—at the right moment, when Ethereum’s state is updated—submits 'the message', 'root', and 'proof' to Ethereum.  
   [See Relayer Code](https://github.com/gear-foundation/vara-eth-cross-ping/tree/main/relayer)
3. **On Ethereum:** a specialized MessageQueue contract verifies the 'proof and root'. If the data is valid, it forwards the message to your destination contract, which emits a “pong” event to confirm delivery.  
   [See Ping Receiver Code](https://github.com/gear-foundation/vara-eth-cross-ping/tree/main/ping-receiver)

## What You Don’t Implement

:::tip
As a developer, you do **not implement** the transport layers. All Merkle root calculations, proof generation, ZK-inclusion proofs, and cross-chain state synchronization are handled by the protocol and bridge infrastructure—automatically, behind the scenes.
:::

Your responsibility is **only your app’s custom logic**: how to format the message and how to process it on arrival.

If you want a deep dive into the protocol’s internals—including proof generation, validator set management, and message processing—please see the official technical overview:  
[**Vara ↔ Ethereum Bridge Technical Overview**](https://wiki.vara.network/docs/bridge/bridge_technical)

The bridge’s protocol ensures that Ethereum can trust which messages were sent from Vara, so you never need to worry about the details of proof construction or on-chain validation.  
Everything you need for secure message delivery is already built in.

## Vara → Ethereum Cross-Chain App’s Implementation Details

Let’s break down the flow and key implementation details of our `PingSender` app on Vara, which is responsible for initiating the cross-chain ping.

[See Vara Program Source](https://github.com/gear-foundation/vara-eth-cross-ping/tree/main/cross-ping)

### Application Flow (Vara)

1. **Initialize the destination:** The program is initialized with the address (H160) of the Ethereum contract that will receive the ping.
2. **Send a ping:** When triggered, it prepares a payload (just the sender’s ActorId), and constructs a bridge request specifying the destination and payload.
3. **Send the message via the built-in bridge:** It uses a special built-in actor (the Gear-Ethereum Bridge, identified by a known ActorId) to submit the message. The message is sent using the `send_bytes_with_gas_for_reply` method, which handles gas and bridge fee logic.
4. **Wait for bridge response:** The program awaits a response from the bridge, which contains a unique nonce and a message hash confirming the message was queued for delivery.
5. **Emit event for relayer:** As soon as the message is confirmed, the program emits a `PingSent` event with all the necessary details (sender, destination, nonce, and message hash). This event is what the relayer listens for.

---

### Key Components and Interfaces

- **Built-in Bridge Actor ID:**  [See Built-in Bridge Actor Addresses](https://wiki.vara.network/docs/build/builtinactors/bia-bridge)
  
  ```rust
  const BRIDGE_ACTOR_ID: [u8; 32] = [ ... ]; // predefined in the protocol
  ```

- **Destination Contract Address:**  
  Set at initialization `new(destination: H160)`, this tells the bridge where on Ethereum to deliver the message.

- **Message Format:**  
  Uses the bridge API:

  ```rust
  BridgeRequest::SendEthMessage { destination, payload }
  ```
  The payload here is simply the sender’s address, but it could be any custom data.

- **Gas & Fee Handling:**  
  The program specifies the gas to be sent for both the bridge request and the reply deposit. No bridge fee is set in this example:
  ```rust
  FEE_BRIDGE: u128 = 0
  ```

- **Event Emission:**  
  Upon receiving a confirmation from the bridge (`BridgeResponse::EthMessageQueued`), the program emits a custom event:

  ```rust
  Event::PingSent(PingSent { ... })
  ```
  This event is what the relayer off-chain listens for to start the next step.

---

### Example: Sending a Ping from Vara

```rust
pub async fn send_ping(&mut self) -> Result<(), Error> {
    // Step 1: Retrieve destination (must be set at init)
    let destination = state.destination.ok_or(Error::DestinationNotInitialized)?;
    let sender = exec::program_id();
    let payload = sender.as_ref().to_vec();
    let bridge_actor_id = ActorId::from(BRIDGE_ACTOR_ID);

    // Step 2: Prepare and encode bridge request
    let request = BridgeRequest::SendEthMessage { destination, payload }.encode();

    // Step 3: Send to built-in bridge, specifying gas and fee
    let reply_bytes = msg::send_bytes_with_gas_for_reply(
        bridge_actor_id,
        request,
        GAS_TO_SEND_REQUEST,
        FEE_BRIDGE,
        GAS_FOR_REPLY_DEPOSIT,
    )
    .map_err(|_| Error::BridgeSendFailed)?
    .await
    .map_err(|_| Error::BridgeReplyFailed)?;

    // Step 4: Decode response from the bridge
    let reply = BridgeResponse::decode(&mut &reply_bytes[..])
        .map_err(|_| Error::InvalidBridgeResponse)?;
    match reply {
        BridgeResponse::EthMessageQueued { nonce, hash } => {
            // Step 5: Emit PingSent event for relayer
            self.emit_event(Event::PingSent(PingSent {
                sender,
                to: destination,
                nonce: Some(nonce.as_u64()),
                message_hash: hash,
            })).expect("Failed to emit PingSent event");
        }
    }
    Ok(())
}
```

### Implementation Notes

- The destination contract address (on Ethereum) can be provided at initialization or hardcoded in the program logic.
- Bridge actor addresses (and other relevant addresses for testnets/mainnet) are published in the official documentation.  
- The payload is an arbitrary byte array (`Vec<u8>`)—it can carry any custom data you need for your use case and will be delivered to the destination contract on Ethereum.

### What Happens Under the Hood?

Once you send your ping message to the built-in bridge, the following steps take place automatically:

- The message enters the bridge’s outbound queue.
- The bridge processes the message as part of the next finalized block.
- As soon as the message is included and the bridge updates its state, it emits a special event:  
  `gearEthBridge.QueueMerkleRootChanged(H256)`

This event signals that a new `Merkle root` has been computed for the outbound queue and your message is now officially included in the bridge batch.

Additionally, a `MessageSend` event is logged, containing your original payload and related metadata.

**In summary:**  
When you see the `QueueMerkleRootChanged` event, you know your ping has been successfully processed by the bridge and is ready to be picked up by a relayer for delivery to Ethereum.

---

## Relayer

A relayer is a permissionless off-chain service that acts as a courier between blockchains. Its only job is to securely deliver messages and proofs from one network to another.

:::info
It does not interpret, modify, or validate the business logic of the messages—it simply transports them.
:::

In the example, the relayer is implemented in Node.js, but you can use any language that can work with the required APIs.

[See Relayer Code](https://github.com/gear-foundation/vara-eth-cross-ping/tree/main/relayer)

### How the Relayer Works (Step by Step)

1. **Connecting to Both Networks**

   First, the relayer needs to connect to both Vara and Ethereum:

   ```js
   const varaApi = await connectVara();
   const ethApi = await connectEthereum();
   const wallet = createWallet(ethApi);
   ```

2. **Subscribe to Events on Vara Chain:**
   - `QueueMerkleRootChanged` (from the bridge): Signals that a new Merkle root has been computed, confirming message inclusion.

     ```js
     listenMerkleRootChanged(varaApi, (root) => {
         console.log('✅ [Vara] New Merkle Root:', root);
         latestVaraMerkleRoot = root;
     });
     ```

   - And `PingSent` (from your PingSender app): Contains metadata (sender, destination, message hash, nonce) required to construct the relay message.

     ```js
     listenPingSent(sails, async (event: PingSentEvent) => {
         // Get proof and metadata for the message
         const proofObj = await getMerkleProof(varaApi, event.messageHash);
         // Build PingMessage object, store for later
         // ...
     });
     ```

3. **Getting Proofs:**
   For every new ping, the relayer fetches the necessary Merkle proof for the message using the bridge’s public RPC API (`getMerkleProof`).  
   This proof cryptographically demonstrates that the message was included in the current Merkle root.

4. **Listening on Ethereum:**
   The relayer also subscribes to the Ethereum network, tracking the `RelayerProxy contract` for `MerkleRootSubmitted` events.

   ```js
   listenRelayerProxy(ethApi, (root, blockNumber) => {
       // When our Merkle root is on Ethereum, relay all collected messages for this root
       // ...
   });
   ```

   This tells the relayer that the Vara Merkle root (containing your message) has now been submitted and acknowledged on Ethereum.
   Only after this event can the message be safely delivered and processed.

5. **Submitting to Ethereum:**
   Once the corresponding `Merkle root` is live on Ethereum, the relayer submits the full message bundle (metadata, proof, and payload) to the `MessageQueue` contract on Ethereum.

   ```js
   sendProcessMessage(
       wallet,
       blockNumber,
       total_leaves,
       leaf_index,
       nonce,
       sender,
       to,
       data, // payload
       proof
   );
   ```

   The relayer pays the gas cost for this operation.

The MessageQueue verifies the proof and, if valid, forwards the payload to the destination contract (your PingReceiver), triggering the next step in your cross-chain logic.

---

## Ethereum Side: The Ping Receiver Contract

The `PingReceiver` contract is the final destination for our cross-chain message. Its only purpose in this example is to accept messages from Vara (delivered via the bridge) and emit a `PongEmitted` event on Ethereum as a proof that the message was successfully received.

Whenever a message is processed, the contract receives both the original sender (as a `bytes32`) and the payload (as a bytes array). This payload can be anything you choose to send from Vara.

This emitted event (`PongEmitted`) serves as cryptographic evidence that the “pong” reached its target.

[See Ping Receiver Code](https://github.com/gear-foundation/vara-eth-cross-ping/tree/main/ping-receiver)

### What Happens Under the Hood?

When the relayer submits a message using `sendProcessMessage`, the bridge’s MessageQueue contract on Ethereum performs several critical checks:

1. **Proof Verification:**  
   It checks the submitted Merkle proof and confirms that your message is indeed included in the provided Merkle root from Vara.

2. **Replay Protection:**  
   Ensures the message has not already been processed (prevents double spending).

3. **Callback to Destination Contract:**  
   If the proof is valid, the MessageQueue contract makes a callback to your destination contract. This is done via a standard interface that your contract must implement, passing along the original sender and payload.

### The Destination Contract: Minimal Example

```solidity
interface IMessageQueueReceiver {
    function processVaraMessage(bytes32 sender, bytes calldata payload)
        external returns (bool);
}

contract PingReceiver is IMessageQueueReceiver {
    event PongEmitted(bytes32 sender);

    function processVaraMessage(bytes32 sender, bytes calldata) external
    override returns (bool) {
        emit PongEmitted(sender);
        return true;
    }
}
```

**How it works:**  
The MessageQueue contract will call `processVaraMessage(sender, payload)` on your contract whenever a valid message arrives.  
You can then handle the payload in any way you wish (in this example, we simply emit a `PongEmitted` event).

The sender comes from the original Vara program, and the payload can be any bytes you sent from Vara.

### What you should know?

- It must implement the `IMessageQueueReceiver` interface.
- The `PingReceiver` contract does not need to validate or interpret the message—it just needs to implement the required interface and emit the pong event.
- This architecture allows you to easily extend the contract to handle more complex logic in the payload.

### How do I know it works?

After you send a cross-chain message, you can verify everything directly in a block explorer (like Etherscan):

1. **Check the MessageQueue contract**  
   Go to your MessageQueue contract and look for the transaction.  
   Make sure that it was successfully executed and that the `MessageProcessed` event was emitted.

2. **Check the Destination contract**  
   Open your DestinationContract in the explorer and look for the relevant event (for example, `PongEmitted`).  
   This confirms that the external method was called on your contract and the pong event was triggered.

If you see an external method call on your destination contract (for example, `processMessage`) and its function signature (Keccak hash), then everything worked correctly.  
Here is an example from a blockchain explorer log:

```text
Method: processMessage(uint256,uint256,uint256,tuple,bytes32[]) 
Logs:              
[topic0] 0xc44ef3954b2c4cf3d82b4d2dda588c48b05f64a42207efd9f512f934ebfb1fcf
*** 
8e3f07ea8c47f40eb9958102005130944dab9a6ffbfe335c2e7f4a5082f51bf9
```

In the logs, you will see the function signature and the call parameters.  
This confirms that your destination contract has received and processed the message!